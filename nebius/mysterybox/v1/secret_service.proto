syntax = "proto3";

package nebius.mysterybox.v1;

import "nebius/mysterybox/v1/secret.proto";
import "nebius/common/v1/metadata.proto";
import "nebius/common/v1/operation.proto";
import "buf/validate/validate.proto";
import "nebius/annotations.proto";

option go_package = "github.com/nebius/gosdk/proto/nebius/mysterybox/v1";
option java_multiple_files = true;
option java_outer_classname = "SecretServiceProto";
option java_package = "ai.nebius.pub.mysterybox.v1";

// A set of methods for managing secrets.
service SecretService {
  option (api_service_name) = "cpl.mysterybox";

  // Creates a new secret in the specified container.
  rpc Create(CreateSecretRequest) returns (common.v1.Operation);

  // Updates an existing secret, excluded its Payload.
  rpc Update(UpdateSecretRequest) returns (common.v1.Operation);

  // Returns the specified secret, without its Payload.
  rpc Get(GetSecretRequest) returns (Secret);

  // Returns the specified secret by name, without its Payload.
  rpc GetByName(GetSecretByNameRequest) returns (Secret);

  // Returns the list of secrets in a specified container, without its Payload.
  rpc List(ListSecretsRequest) returns (ListSecretsResponse);

  // Soft delete secret
  rpc Delete(DeleteSecretRequest) returns (common.v1.Operation);

  // Undelete secret version
  rpc Undelete(UndeleteSecretRequest) returns (common.v1.Operation);
}

message CreateSecretRequest {
  common.v1.ResourceMetadata metadata = 1;

  SecretSpec spec = 2;
}

message UpdateSecretRequest {
  common.v1.ResourceMetadata metadata = 1;

  SecretSpec spec = 2;
}

message GetSecretRequest {
  // ID of secret to return.
  string id = 1 [(buf.validate.field).required = true];

  // By default, Get doesn't return resource if it is scheduled for deletion.
  // If show_scheduled_for_deletion = true, the Get operation returns the resource even if it is scheduled for deletion.
  // If show_scheduled_for_deletion = false, the Get method returns the NOT_FOUND gRPC status code.
  bool show_scheduled_for_deletion = 2;
}

message GetSecretByNameRequest {
  // ParentId and name of the secret to return.
  string parent_id = 1 [(buf.validate.field).required = true];

  string name = 2 [(buf.validate.field).required = true];

  reserved 3;
}

message ListSecretsRequest {
  // ParentId of the secret to return.
  string parent_id = 1 [(buf.validate.field).required = true];

  // The maximum number of results per page to return. If the number of available
  // results is larger than [page_size], the service returns a [ListSecretsResponse.next_page_token]
  // that can be used to get the next page of results in subsequent list requests.
  // Default value: 100.
  int64 page_size = 2 [
    (buf.validate.field) = {
      int64: { lte: 1000, gte: 0 },
      ignore: IGNORE_IF_UNPOPULATED
    }
  ];

  // Page token. To get the next page of results, set [page_token] to the
  // [ListSecretsResponse.next_page_token] returned by a previous list request.
  string page_token = 3;

  // By default, List operation doesn't include resources that are scheduled for deletion.
  // If show_scheduled_for_deletion = true, the listing includes resources that are scheduled for deletion.
  bool show_scheduled_for_deletion = 4;
}

message ListSecretsResponse {
  // This token allows you to get the next page of results for list requests. If the number
  // of results is greater than the specified [ListSecretsRequest.page_size], use
  // the [next_page_token] as the value for the [ListSecretsRequest.page_token] query parameter
  // in the next list request. Each subsequent list request will have its own
  // [next_page_token] to continue paging through the results.
  string next_page_token = 2;

  // List of secrets in the specified container, without its Payload.
  repeated Secret items = 3;
}

message DeleteSecretRequest {
  // ID of the secret to soft-delete.
  string id = 1 [(buf.validate.field).required = true];
}

message UndeleteSecretRequest {
  // ID of the secret version to soft-delete.
  string id = 1 [(buf.validate.field).required = true];

  // A new Secret name in case the current one is already in use.
  // Empty value in name field means "use original name for undeleted Secret".
  // Undelete will fail if a Secret with the same name already exists.
  string name = 2;
}
